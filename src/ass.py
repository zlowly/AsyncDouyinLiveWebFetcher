import datetime
import math
import argparse # Import argparse for command-line arguments
import cv2      # Import OpenCV for reading video dimensions
import os       # Import os for path operations
import json     # Import json for parsing JSON files
import sys      # Import sys for checking command-line arguments

def parse_timestamp(timestamp_str):
    """
    灵活地将带有或不带毫秒的时间戳字符串转换为 datetime 对象。

    Args:
        timestamp_str (str): 要解析的时间戳字符串。

    Returns:
        datetime.datetime: 解析后的 datetime 对象。
        None: 如果无法解析，则返回 None。
    """
    # 尝试解析带毫秒的格式
    try:
        # %Y-%m-%d %H:%M:%S,%f 中的 %f 代表微秒
        # Python 的 datetime.strptime() 使用 %f 来处理毫秒和微秒，
        # 即使字符串只有毫秒，它也能正确解析。
        return datetime.datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S,%f')
    except ValueError:
        # 如果失败，尝试解析不带毫秒的格式
        return datetime.datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')

def format_timedelta_to_ass(td):
    """
    Formats a timedelta object to ASS time string (H:MM:SS.cc).
    将 timedelta 对象格式化为 ASS 时间字符串 (H:MM:SS.cc)。
    """
    total_seconds = int(td.total_seconds())
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    # ASS uses centiseconds (1/100 of a second)
    centiseconds = int(td.microseconds / 10000)
    return f"{hours}:{minutes:02}:{seconds:02}.{centiseconds:02}"

def generate_ass_scrolling_danmaku(input_filepath, output_filepath, video_width_param=1280, video_height_param=720, font_size=48, scroll_speed_pixels_per_second=100, buffer_pixels_after_tail_enters=50, video_start_datetime_str=None, video_file_path=None):
    """
    根据原始弹幕文本和时间戳生成 ASS 滚动弹幕文件，并尝试避免垂直重叠。
    轨道在弹幕尾部完全展现后加上缓冲距离即可被视为空闲。
    原始弹幕数据格式：
    TSV: 日期时间字符串\t弹幕发言人\t弹幕内容
    JSON: [{ "timestamp": "YYYY-MM-DD HH:MM:SS", "speaker": "发言人", "content": "弹幕内容" }, ...]
    日期时间格式示例：2025-07-02 14:11:19
    显示格式：浅蓝色字体方括号包围的发言人，白色弹幕内容。

    Args:
        input_filepath (str): 原始弹幕文本文件的路径，支持 TSV 或 JSON 格式。
        output_filepath (str): 生成的 ASS 文件的输出路径。
        video_width_param (int): 视频的宽度（像素），如果未提供 video_file_path 则使用此值。
        video_height_param (int): 视频的高度（像素），如果未提供 video_file_path 则使用此值。
        font_size (int): 弹幕的字体大小。
        scroll_speed_pixels_per_second (int): 弹幕每秒滚动的像素数（决定速度）。
        buffer_pixels_after_tail_enters (int): 弹幕尾部完全进入屏幕后，与下一条弹幕头部之间所需的像素缓冲距离。
        video_start_datetime_str (str, optional): 视频的起始时间点，格式为 'YYYY-MM-DD HH:MM:SS'。
                                                  如果未提供，将使用第一条弹幕的时间作为视频起始时间。
        video_file_path (str, optional): 视频文件的路径。如果提供，将从该文件获取视频宽度和高度，
                                          并覆盖 video_width_param 和 video_height_param。
    """

    video_width = video_width_param
    video_height = video_height_param

    # If video_file_path is provided, try to get dimensions from it
    # 如果提供了 video_file_path，尝试从文件中获取尺寸
    if video_file_path:
        try:
            cap = cv2.VideoCapture(video_file_path)
            if not cap.isOpened():
                raise IOError(f"无法打开视频文件: {video_file_path}")
            
            video_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            video_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            cap.release()
            print(f"从视频文件 '{video_file_path}' 获取到视频尺寸：宽度={video_width}, 高度={video_height}")
        except Exception as e:
            print(f"警告: 无法从视频文件 '{video_file_path}' 获取尺寸。将使用默认或指定参数值。错误: {e}")
            # Fallback to provided parameters or defaults
            # 回退到提供的参数或默认值
            video_width = video_width_param
            video_height = video_height_param

    # Estimated line height based on font size. Adjust if needed for accurate spacing.
    # 根据字体大小估算的行高。如果需要精确间距，请调整。
    line_height = font_size + 10 # Adding 10 pixels for padding between lines (for DanmakuStyle's Alignment 7)
    
    # Calculate available vertical channels
    # 计算可用的垂直通道数量
    num_channels = math.floor(video_height / line_height)
    if num_channels <= 0:
        print("错误: 视频高度太小，无法容纳任何弹幕轨道。请检查 video_height 或 font_size。")
        return

    # Track when each channel becomes free. Stores the time at which the channel is available.
    # 跟踪每个通道何时变为空闲。存储通道可用的时间。
    channel_free_time = [datetime.timedelta(0)] * num_channels

    ass_header = f"""
[Script Info]
; Script generated by a Python tool
Title: Generated Scrolling Danmaku (TSV/JSON Input)
ScriptType: v4.00+
Collisions: Normal
PlayResX: {video_width}
PlayResY: {video_height}
Timer: 100.0000

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: DanmakuStyle,Arial,{font_size},&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,7,20,20,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""

    danmaku_lines_to_write = []
    
    # List to store parsed danmaku with their calculated length for proper sorting/processing
    # 存储解析后的弹幕列表，包含其计算出的长度，以便正确排序/处理
    parsed_danmaku_data = []
    
    # Determine the reference datetime for video start
    # 确定视频开始的参考日期时间
    reference_datetime = None
    if video_start_datetime_str:
        try:
            reference_datetime = parse_timestamp(video_start_datetime_str)
        except ValueError:
            print(f"错误: 无效的 video_start_datetime_str 格式 '{video_start_datetime_str}'。应为 'YYYY-MM-DD HH:MM:SS'。")
            return

    first_danmaku_datetime_found = False

    # --- File reading and format detection ---
    try:
        with open(input_filepath, 'r', encoding='utf-8') as f:
            file_content = f.read() # Read entire content
    except FileNotFoundError:
        print(f"错误: 找不到输入文件 '{input_filepath}'。")
        return
    except Exception as e:
        print(f"读取输入文件 '{input_filepath}' 时发生未知错误: {e}")
        return

    file_extension = os.path.splitext(input_filepath)[1].lower()

    if file_extension == '.json':
        try:
            json_data = json.loads(file_content) # Use loads for string content
            if not isinstance(json_data, list):
                raise ValueError("JSON input must be a list of danmaku objects.")
            
            for line_num, item in enumerate(json_data, 1):
                if not all(k in item for k in ["timestamp", "speaker", "content"]):
                    print(f"警告: JSON 对象 {line_num} 缺少必要的键 (timestamp, speaker, content)。跳过。")
                    continue
                
                datetime_str = item["timestamp"]
                speaker = item["speaker"]
                content = item["content"]

                current_datetime = parse_timestamp(datetime_str)

                if reference_datetime is None and not first_danmaku_datetime_found:
                    reference_datetime = current_datetime
                    first_danmaku_datetime_found = True
                
                if reference_datetime is None: # Should not happen if data is valid
                    print(f"错误: 无法确定视频起始时间。请提供 video_start_datetime_str 或确保输入文件不为空。")
                    return

                timestamp_ms = int((current_datetime - reference_datetime).total_seconds() * 1000)
                
                full_text_for_width_estimate = f"[{speaker}]{content}"
                estimated_char_width_ratio = 0.6 
                if any('\u4e00' <= char <= '\u9fff' for char in full_text_for_width_estimate): 
                    estimated_char_width_ratio = 1.0
                
                text_width = len(full_text_for_width_estimate) * (font_size * estimated_char_width_ratio) 
                
                parsed_danmaku_data.append({
                    'timestamp_ms': timestamp_ms,
                    'speaker': speaker,
                    'content': content,
                    'text_width': text_width
                })
        except json.JSONDecodeError as e:
            print(f"错误: 无法解析 JSON 文件 '{input_filepath}'。请检查 JSON 格式。错误: {e}")
            return
        except ValueError as e: # Catch datetime parsing errors here
            print(f"JSON 数据中日期时间格式错误: {e}")
            return
        except Exception as e:
            print(f"处理 JSON 数据时发生未知错误: {e}")
            return
    else: # Default to TSV if not JSON or unknown extension
        # Split the content into lines for TSV parsing
        for line_num, line in enumerate(file_content.splitlines(), 1):
            line = line.strip()
            if not line:
                continue
            try:
                parts = line.split('\t', 2)
                if len(parts) != 3:
                    raise ValueError("Incorrect number of columns")
                
                datetime_str, speaker, content = parts
                
                current_datetime = datetime.datetime.strptime(datetime_str, '%Y-%m-%d %H:%M:%S')

                if reference_datetime is None and not first_danmaku_datetime_found:
                    reference_datetime = current_datetime
                    first_danmaku_datetime_found = True

                if reference_datetime is None: # Should not happen if data is valid
                    print(f"错误: 无法确定视频起始时间。请提供 video_start_datetime_str 或确保输入文件不为空。")
                    return
                
                timestamp_ms = int((current_datetime - reference_datetime).total_seconds() * 1000)
                
                full_text_for_width_estimate = f"[{speaker}]{content}"
                estimated_char_width_ratio = 0.6 
                if any('\u4e00' <= char <= '\u9fff' for char in full_text_for_width_estimate): 
                    estimated_char_width_ratio = 1.0
                
                text_width = len(full_text_for_width_estimate) * (font_size * estimated_char_width_ratio) 
                
                parsed_danmaku_data.append({
                    'timestamp_ms': timestamp_ms,
                    'speaker': speaker,
                    'content': content,
                    'text_width': text_width
                })
            except ValueError as e:
                print(f"警告: 跳过无效行 {line_num}: '{line}'。格式应为 'YYYY-MM-DD HH:MM:SS\\t发言人\\t弹幕内容'。错误: {e}")
                continue
            except Exception as e:
                print(f"处理 TSV 文件行 {line_num} 时发生未知错误: {e}")
                continue

    # If no danmaku data was parsed, exit
    if not parsed_danmaku_data:
        print("没有可用的弹幕数据进行处理。请检查输入文件内容。")
        return

    # Sort danmaku by timestamp to process them in order
    # 按时间戳排序弹幕，以便按顺序处理
    parsed_danmaku_data.sort(key=lambda x: x['timestamp_ms'])

    # Constants for scroll path
    # 滚动路径的常量
    padding_right_of_screen = 50 # Initial offset from right edge of screen for danmaku to start
    padding_left_of_screen = 50 # Offset from left edge of screen for danmaku to fully exit

    # Define colors using ASS BGR hexadecimal format: &HBBGGRR&
    # Light blue for speaker, white for content
    # 定义颜色，使用 ASS BGR 十六进制格式：&HBBGGRR&
    # 发言人浅蓝色，弹幕内容白色
    speaker_color_ass = "&HFFC0C0&" # Light Blue
    content_color_ass = "&H00FFFFFF&" # White (same as PrimaryColour in Style)

    for danmaku in parsed_danmaku_data:
        desired_start_time_td = datetime.timedelta(milliseconds=danmaku['timestamp_ms'])
        
        # Scrolling start X (left edge of danmaku text starts here)
        # 滚动起始X坐标（弹幕文本的左边缘从这里开始）
        start_x = video_width + padding_right_of_screen 
        # Scrolling end X (left edge of danmaku text ends here)
        # 滚动结束X坐标（弹幕文本的左边缘在这里结束）
        end_x = -danmaku['text_width'] - padding_left_of_screen

        # Total distance the danmaku's left edge travels
        # 弹幕左边缘滚动的总距离
        total_scroll_distance = start_x - end_x

        # Calculate actual scroll duration for this danmaku based on speed and total distance
        # 根据速度和总距离计算当前弹幕的实际滚动时长
        scroll_duration_current_danmaku = datetime.timedelta(seconds=total_scroll_distance / scroll_speed_pixels_per_second)
        
        # Find a free channel
        # 寻找空闲通道
        assigned_channel = -1
        earliest_free_time = datetime.timedelta.max # Initialize with a very large time
        
        for i in range(num_channels):
            # Check if channel is free at the desired_start_time_td
            # 检查通道在期望的开始时间是否空闲
            if channel_free_time[i] <= desired_start_time_td: 
                assigned_channel = i
                break # Found a free channel, use it
            elif channel_free_time[i] < earliest_free_time: # Find the channel that frees up earliest
                earliest_free_time = channel_free_time[i]
                assigned_channel_if_wait = i

        # Determine the actual start time for this danmaku
        # 确定这条弹幕的实际开始时间
        actual_danmaku_start_time_td = desired_start_time_td
        if assigned_channel == -1: # No channel is free right now, wait for the earliest one
            assigned_channel = assigned_channel_if_wait
            actual_danmaku_start_time_td = earliest_free_time # Adjust start time to when channel is free

        # Calculate danmaku's full end time (when it fully exits screen)
        # 计算弹幕的完整结束时间（完全滚出屏幕时）
        danmaku_full_exit_time_td = actual_danmaku_start_time_td + scroll_duration_current_danmaku
        
        # --- New logic for channel release time ---
        # Calculate the time when the danmaku's *tail* (rightmost part) has fully entered the screen.
        # This happens when the left edge of the danmaku has moved from 'start_x' to 'video_width - danmaku_text_width'.
        # Distance moved for tail to enter screen = start_x - (video_width - danmaku_text_width)
        distance_for_tail_to_enter_screen = start_x - (video_width - danmaku['text_width'])

        # Time taken for this distance to be covered
        time_for_tail_to_enter_screen_relative_to_start = datetime.timedelta(seconds=distance_for_tail_to_enter_screen / scroll_speed_pixels_per_second)
        
        # Time when the tail has fully entered + buffer time
        # 尾部完全进入屏幕的时间 + 缓冲时间
        buffer_time_td = datetime.timedelta(seconds=buffer_pixels_after_tail_enters / scroll_speed_pixels_per_second)
        
        channel_release_time_td = actual_danmaku_start_time_td + time_for_tail_to_enter_screen_relative_to_start + buffer_time_td

        # Ensure the release time is not after its full exit time, in case of very short danmaku/high speed
        # 确保释放时间不超过弹幕完全滚出屏幕的时间，以防弹幕过短/速度过快
        channel_release_time_td = min(channel_release_time_td, danmaku_full_exit_time_td)

        # Occupy the chosen channel with the calculated release time
        # 用计算出的释放时间占用所选通道
        channel_free_time[assigned_channel] = channel_release_time_td

        # Calculate vertical position for the assigned channel
        # 为分配的通道计算垂直位置
        # Alignment 7 means middle-center, so y_pos is the vertical center of the text.
        # 垂直居中，y_pos 是文本的垂直中心线
        y_pos = assigned_channel * line_height + (line_height / 2) 

        # Construct the danmaku text with ASS override tags for styling
        # 使用 ASS 覆盖标签构建弹幕文本以进行样式设置
        # {\c&HBBGGRR&} for color, {\b1} for bold, {\b0} for no bold
        formatted_text = (
            f"{{\\c{speaker_color_ass}}}[{danmaku['speaker']}]{{\\c{content_color_ass}}}{danmaku['content']}"
        )

        # Use \move tag for right-to-left scrolling
        # 使用 \move 标签实现从右向左滚动
        ass_line = f"Dialogue: 0,{format_timedelta_to_ass(actual_danmaku_start_time_td)},{format_timedelta_to_ass(danmaku_full_exit_time_td)},DanmakuStyle,,0,0,0,,{{\\move({start_x},{y_pos},{end_x},{y_pos})}}{formatted_text}"
        danmaku_lines_to_write.append(ass_line)

    with open(output_filepath, 'w', encoding='utf-8') as f:
        f.write(ass_header.strip() + "\n")
        for line in danmaku_lines_to_write:
            f.write(line + "\n")

    print(f"成功生成 ASS 文件：'{output_filepath}'")
    print(f"请确保视频的尺寸与脚本中设置的 video_width={video_width}, video_height={video_height} 一致，以获得最佳效果。")
    print(f"总共分配了 {num_channels} 个弹幕轨道。")
    print(f"每行弹幕估算高度为 {line_height} 像素，行尾缓冲为 {buffer_pixels_after_tail_enters} 像素。")


# --- 使用示例 ---
if __name__ == "__main__":
    # Create the parser
    # 创建解析器
    parser = argparse.ArgumentParser(
        description="Generate ASS scrolling danmaku from TSV or JSON input. "
                    "Automatically detects input file format based on extension (.tsv or .json).",
        formatter_class=argparse.RawTextHelpFormatter # Preserve newlines in help text
    )
    
    # Add arguments
    # 添加参数
    parser.add_argument('input_filepath', type=str, 
                        help='Path to the input TSV or JSON file (e.g., input.tsv or input.json)')
    parser.add_argument('output_filepath', type=str, 
                        help='Path to the output ASS file (e.g., output.ass)')
    parser.add_argument('--video_width', type=int, default=1280, 
                        help='Width of the video in pixels. Used if --video_file is not provided or fails. (default: 1280)')
    parser.add_argument('--video_height', type=int, default=720, 
                        help='Height of the video in pixels. Used if --video_file is not provided or fails. (default: 720)')
    parser.add_argument('--font_size', type=int, default=48, help='Font size of the danmaku (default: 48)')
    parser.add_argument('--scroll_speed', type=int, default=100, help='Danmaku scroll speed in pixels per second (default: 100)')
    parser.add_argument('--buffer_pixels', type=int, default=50, help='Buffer pixels after danmaku tail enters screen (default: 50)')
    parser.add_argument('--video_start_time', type=str, default=None, 
                        help="Video's start datetime in 'YYYY-MM-DD HH:MM:SS' format. "
                             "If not provided, the first danmaku's time will be used as video start.")
    parser.add_argument('--video_file', type=str, default=None, 
                        help="Path to the video file (e.g., video.mp4). If provided, "
                             "script will try to get video width and height from it, "
                             "overriding --video_width and --video_height.")

    # If no arguments are provided, print help message and exit
    # 如果没有提供参数，打印帮助信息并退出
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    # Parse arguments
    # 解析参数
    args = parser.parse_args()

    # Call the main function with parsed arguments
    # 使用解析后的参数调用主函数
    generate_ass_scrolling_danmaku(
        input_filepath=args.input_filepath,
        output_filepath=args.output_filepath,
        video_width_param=args.video_width, 
        video_height_param=args.video_height, 
        font_size=args.font_size,
        scroll_speed_pixels_per_second=args.scroll_speed,
        buffer_pixels_after_tail_enters=args.buffer_pixels,
        video_start_datetime_str=args.video_start_time,
        video_file_path=args.video_file 
    )

    # Example input.tsv content:
    # 2025-07-02 14:11:19	用户A	这是一条测试弹幕！
    # 2025-07-02 14:11:20	发言人B	这条弹幕紧随其后，但会被安排到不同的轨道。
    # 2025-07-02 14:11:21	管理员	第三条弹幕，内容可以长一些，看看滚动效果。
    # 2025-07-02 14:11:22	游客123	又一条，如果上面有空轨道，它会立刻显示。
    # 2025-07-02 14:11:23	直播君	这是第五条弹幕，可能会等待空闲轨道。
    # 2025-07-02 14:11:24	某某	第六条，看看缓冲效果。
    # 2025-07-02 14:11:25	吃瓜群众	第七条，测试密集弹幕。

    # Example input.json content:
    # [
    #     {
    #         "timestamp": "2025-07-02 14:11:19",
    #         "speaker": "用户A",
    #         "content": "这是一条测试弹幕！"
    #     },
    #     {
    #         "timestamp": "2025-07-02 14:11:20",
    #         "speaker": "发言人B",
    #         "content": "这条弹幕紧随其后，但会被安排到不同的轨道。"
    #     },
    #     {
    #         "timestamp": "2025-07-02 14:11:21",
    #         "speaker": "管理员",
    #         "content": "第三条弹幕，内容可以长一些，看看滚动效果。"
    #     }
    # ]

